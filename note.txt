
it is important to acknowledg that the routung functionality provided by Go's servemux is pretty lightweight.
 it does not support routing based on the request method, it doesnot support clean URLs with variable in them,
 it does not support regexp-based patterns.
 
 but don't let that put you off, the reality is that Go's servemux can still get you quite far, and for many 
 applications perfectly sufficient. for the times that you need more, there is a huge choice of third-party 
 routers that you can use instead of Go's servermux

    RESPONSE METHOD IN GO

 1. w. methods (from http.ResponseWriter)
These give you raw control:
w.Write([]byte("...")) ‚Üí write body
w.Header().Set("Key", "Value") ‚Üí set headers
w.WriteHeader(http.StatusNotFound) ‚Üí set status
üëâ Lowest level, full flexibility.

2. http. helper functions (from net/http)
These are convenience wrappers that internally call w. methods:
http.NotFound(w, r) ‚Üí sends 404 with default message
http.Error(w, "msg", code) ‚Üí sends status + error body
http.Redirect(w, r, "/new", code) ‚Üí sends redirect
http.ServeFile(w, r, "file.html") ‚Üí serves files
üëâ Saves boilerplate for common cases.

3. json. methods (from encoding/json)
These handle JSON serialization into the response:
json.NewEncoder(w).Encode(data) ‚Üí writes JSON response
(Make sure to set w.Header().Set("Content-Type", "application/json") first)
üëâ Best when building APIs.

‚úÖ So yes:
Use w. when you want raw/manual control.
Use http. when you want built-in helpers.
Use json. when returning structured JSON data.

         WHAT IS THE DIFFERENT B/ W.HEADER.SET() AND W.WRITEHEADER
üîπ w.Header().Set(key, value)

What it does: modifies the HTTP response headers map.
Example:
w.Header().Set("Content-Type", "application/json")

You can call this multiple times before the response is sent.
Once the headers are sent (after WriteHeader or the first Write), further changes to headers are ignored.

üîπ w.WriteHeader(statusCode)
What it does: sets the HTTP status code (e.g., 200, 404, 500).
Example:
w.WriteHeader(http.StatusNotFound) // 404

Must be called before writing the body (w.Write).
If you don‚Äôt call it, Go automatically sends 200 OK when you first call w.Write.

üîë Key Differences
Method	Purpose	Example
w.Header().Set("Key", "Value")	Sets header fields (like metadata)	Content-Type, Cache-Control, etc.
w.WriteHeader(code)	Sets status code	200 OK, 404 Not Found, 500 Internal Server Error
‚ö†Ô∏è Common Gotcha
w.Write([]byte("hello"))
w.WriteHeader(http.StatusNotFound) // ‚ùå too late


By the time you call w.Write, Go already sent 200 OK.
Status code must be set before writing any body.
‚úÖ In short:
Header().Set ‚Üí for response headers (must be before writing).
WriteHeader ‚Üí for status code (must be before writing).

   THE HTTP.ERROR SHORTCUT
if you want to send a non-200 status code and a plain-text response body, 
  then it is a good opportunity to use the http.Error() shortcut. this is a lightweight
  helper function which takes a given message and status code, then calls the w.WriteHeader
  and w.write() methods behind-the-scenes for us

  SYSTEM-GENERATED HEADERS AND CONTENT SNIFFING
when sending a response Go will automatically set three system-generated headers for you:
  - Date
  - Content-Length
  - Content-Type - automatically detected by go's http.DetectContentType() function.

   MANIPULATING THE HEADER MAP 
in the code above we used w.Header().set() to add a new header to the response header map. but there're 
 also Add(), Del(), Get() and value() methods that you can use to read and manipulate the headers and map too
 
 // Set a new cache-control header. If an existing "Cache-Control" header exists
// it will be overwritten.
w.Header().Set("Cache-Control", "public, max-age=31536000")
// In contrast, the Add() method appends a new "Cache-Control" header and can
// be called multiple times.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")
// Delete all values for the "Cache-Control" header.
w.Header().Del("Cache-Control")
// Retrieve the first value for the "Cache-Control" header.
w.Header().Get("Cache-Control")
// Retrieve a slice of all values for the "Cache-Control" header.
w.Header().Values("Cache-Control")

the Del() method doesnot remove system-generated headers. to suppress these, you need to access the underlying header
 map directly and set the value to nil.

if you want to suppress the Date header, for eg, you need to write
 w.Header()["Date"] = nil

     THE IO.WRITER INTERFACE
The code above introduced another new thing behind-the-scenes. If you take a look at the
documentation for the fmt.Fprintf() function you‚Äôll notice that it takes an io.Writer as the
first parameter‚Ä¶
func Fprintf(w io.Writer, format string, a ...any) (n int, err error)
‚Ä¶but we passed it our http.ResponseWriter object instead ‚Äî and it worked fine.
We‚Äôre able to do this because the io.Writer type is an interface, and the
http.ResponseWriter object satisfiesthe interface because it has a w.Write() method.

we can write to the console as well - fmt.Fprintf(os.Stdout, "Hello %s\n", "World")

  PROJECT STRUCTURE AND ORGANIZATION
- The cmd directory will contain the application-specific code for the executable applications
   in the project. For now we‚Äôll have just one executable application ‚Äî the web application ‚Äî
   which will live under the cmd/web directory
- the internal directory will contain the ancillary non-application-specific code used in the project.
   we will use it to hold potentially reuseable code like validation helpers and the SQL database models for the project

- the ui directory will contain the user-interface assets used by the web application. specifically, the ui/html directory will contain
   HTML templates and the ui/static files (like CSS and images)


  EMBEDING FILES 
 Go 1.16 introduces the embed package which makes it possibleto embed files into your Go program itself rather than
  reading them from disk

 for now reading our template files from the disk works fine and it is conceptually simpler that using the embed package, but we'll revisit this 
  and explain how to use the embed functionality as an alternative later in the book

  SERVING STATIC FILES
  The Http.Fileserver handler

  Go's net/http package ships with a built-in http.Fileserver handler which you can use to serve files over
   Http from a specific directory. let's add a new route to our application so that all requests which begin with "/static/"
   are handled using this


   
<!-- 
    THE BLOCK ACTION
 
  in the code below we've used the {{template}} action to invke one template from another. But Go also provides a {{block}}...{{end}}
  action which you use instead. this acts like the {{template}} action, except it allows you to specify some default content if the template 
   being invoked doesn't exist in the current template set.

   in the context of a web application, this is useful when you want to provide some default content (such as sidebar) which individual pages 
     can override on a case-by-case basis if they need to.
 
syntatically you use it like this

  {{define "base"}}
     <h1>an example template</h1>
     {{block "sidebar" . }}
        <p>my default sidebar content </p>
     {{end}}
  {{end}}
 
-->



{{define "base"}}
<!doctype html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<title>{{template "title" .}} - Snippetbox</title>
<!-- link to the CSS stylesheet and favicon -->
 <link rel="stylesheet" href="/static/css/main.css">
 <link rel="shortcut icon" href="/static/img/favicon.ico" type="image/x-icon">
 <!-- also link to some fonts hosted by google -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700">
</head>
<body>
<header>
<h1><a href='/'>Snippetbox</a></h1>
</header>
<!-- Invoke the navigation template -->
 {{template "nav"}}
<main>
{{template "main" .}}
</main>
<footer>Powered by <a href='https://golang.org/'>Go</a></footer>
<!--and include the javascript file...  -->
<script src="/static/js/main.js" type="text/javascript"></script>
</body>
</html>
{{end}}


   DISABLING DIRECTORY LISTINGS
If you want to disable directory listings there are a few different approaches you can take.
The simplest way? Add a blank index.html file to the specific directory that you want to
disable listings for. This will then be served instead of the directory listing, and the user will
get a 200 OK response with no body

A more complicated (but arguably better) solution is to create a custom implementation of
http.FileSystem, and have it return an os.ErrNotExist error for any directories. A full
explanation and sample code can be found in this blog post.


 THE HTTP HANDLER INTERFACE
Strictly speaking a handler is an object which satisfies the http.handler interface
 type handler interface {
   serveHttp(ResponseWriter, *Request)
 }

in simple terms, this is basically means that to be a handler an object must have a serveHttp() method with the exact signiture
 ServerHttp(http.ResponseWriter, *http.Request)

 so in simpler terms a handler might look something like this
  type home struct {}
  func (h *home) serverHTTP(W http.ResponseWritter, r *http.Request){
   w.Write([]byte("this is my home page"))
  }

   ENVIRONMENT VARIABLES

if you have built and deployed web applications before, then you're probably thinking what abut environment variables?
 surely it is a good-practice to store configuration settings there?

 if you want, you can store your configuration settings in environment variable and access them directly from your application by
  using the os.Getenv() function like so : 
     addr := os.Getenv("SNIPPETBOX_ADDR)

   but this time some drawbacks compared to using command-line flags. you can't specify a default setting (the return value from os.Getenv)
    is the empty string if the environment variable doesnot exist, you don't get the -help functionality that you do with command-line flags
     and the return value from os.Getenv() is always a string - you don't get automatic type conversions like you o with flag.Int() and the 
      other command line functions

   INSTEAD, you can get the best of both worlds by passing the environment variable as a command-line flag when starting the application
    setting environment variable =  $env:SNIPPETBOX_ADDR=":9999"
    run using the port store on the environment variable = go run ./cmd/web -addr="$env:SNIPPETBOX_ADDR"

    BOOLEAN FLAGS 
    flag.Bool()
     go run ./example -flag=true =  go run ./example -flag
       but for false we have to explicitly say so.

   PRE-EXISTING VARIABLES
     it is possible to parse command-line flag values into the memory addresses of pre-existing variables, using the flag.StringVar(),
      flag.IntVar, flagBoolVar() and other functions.

      type config struct {
          addr string
       staticDir string
    }
     var cfg config
     flag.StringVar(&cfg.addr, "addr", ":4000", "HTTP network address")
     flag.StringVar(&cfg.staticDir, "static-dir", "./ui/static", "Path to static assets")
     flag.Parse()


  LOG.NEW() - function is used to create custom loggers